/**
 * This Java Class is part of the Impro-Visor Application
 *
 * Copyright (C) 2005-2019 Robert Keller and Harvey Mudd College
 *
 * Impro-Visor is free software; you can redistribute it and/or modify it under
 * the terms of the GNU General Public License as published by the Free Software
 * Foundation; either version 2 of the License, or (at your option) any later
 * version.
 *
 * Impro-Visor is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of merchantability or fitness
 * for a particular purpose. See the GNU General Public License for more
 * details.
 *
 * You should have received a copy of the GNU General Public License along with
 * Impro-Visor; if not, write to the Free Software Foundation, Inc., 51 Franklin
 * St, Fifth Floor, Boston, MA 02110-1301 USA
 */
package imp.lickgen;

import imp.roadmap.brickdictionary.Block;
import imp.data.Chord;
import imp.data.ChordPart;
import imp.data.Note;
import imp.gui.Notate;
import imp.osc.*;
import imp.ImproVisor;
import static imp.lickgen.Terminals.getDuration;
import static imp.lickgen.Terminals.isTerminal;
import static imp.lickgen.Terminals.isWrappedTerminal;
import imp.util.ErrorLog;
import java.io.*;
import java.util.ArrayList;
import polya.Arith;
import polya.Polylist;
import polya.PolylistBuffer;
import polya.PolylistEnum;
import polya.Tokenizer;

/*
 * @author David Morrison, modifications by Robert Keller, 21 June 2012,
 * Revised method by Robert Keller, 1 August 2014
 * Further revised by Robert Keller, 31 July 2017 to include wrappers share,
 * unshare, fill
 * Further revised by Robert Keller, 3 August 2017 to include unshareall, which
 * will be inserted automatically after any fill.
 */
public class Grammar
  {

    /**
     * Set traceLevel to 1 to see which rules are being applied and also
     * any bricks identified.
     *
     * Set traceLevel to 2 to see frontier of derivation in addition to rules.
     */
    int traceLevel = 0;

// Rule tags:
    public static final String START = "startsymbol";
    public static final String TERMINAL = "terminals";
    public static final String BASE = "base";
    public static final String RULE = "rule";
    public static final String PARAM = "parameter";
    public static final String COMMENT = "comment";
// Wrappers:
    public static final String FILL = "fill";
    public static final String NONE = "none";
    public static final String SHARE = "share";
    public static final String UNSHARE = "unshare";
    public static final String UNSHAREALL = "unshareall";
    public static final String MUSE_SWITCH = "muse-switch"; // keyword for muse
    public static final String MUSE_DEFAULT = "default";    // keyword for muse
// Special forms:
    public static final String BUILTIN = "builtin";
    public static final String SPLICE = "splice";
    public static final String LITERAL = "literal";
// Operators:
    public static final String PLUS = "+";
    public static final String MINUS = "-";
    public static final String TIMES = "*";
    public static final String DIVIDE = "/";
// Builtin variables:
    public static final String BRICK = "brick";
    public static final String MUSE = "muse";
    public static final String CHORD_FAMILY = "chord-family";
    public static final String EXPECTANCY = "expectancy";
    public static final String SYNCOPATION = "syncopation";
    public static final String HIGH = "high";
    public static final String MEDIUM = "medium";
    public static final String LOW = "low";
    public static final Double ONE = new Double(1);
    public static final Double ZERO = new Double(0);
    Polylist rules = Polylist.nil;
    String startSymbol = null; // to be set
    private Notate notate;
    private int currentSlot;
    private int chordSlot;

    public Grammar(String file)
    {
        loadGrammar(file);
    }

    public Grammar(Polylist p)
    {
        rules = p;
    }

    /**
     * An ExpansionResult is the result of expanding a non-terminal or wrapped
     * non-terminal according to grammar rules.
     */
    class ExpansionResult
      {

        public ExpansionResult(Polylist stack, int numSlotsToFill)
        {
            this.stack = stack;
            this.numSlotsToFill = numSlotsToFill;
        }
        Polylist stack;
        int numSlotsToFill;

        public boolean moreToDo()
        {
            return numSlotsToFill > 0 && stack.nonEmpty();
        }

        @Override
        public String toString()
        {
            return "slotsToFill = " + numSlotsToFill + " stack = " + stack;
        }
      }

    /**
     * terminalBuffer contains all terminals generated by the grammar in
     * one call to run. applyRules will have a side-effect on it.
     */
    PolylistBuffer terminalBuffer;

    /**
     *
     * @param startSlot
     * @param initialNumSlots
     * @param myNotate
     * @param whetherToTrade
     * @param improVisorFirst
     * @param tradingQuantum
     * @return
     */
    public Polylist run(int startSlot,
                        int initialNumSlots,
                        Notate myNotate,
                        boolean whetherToTrade,
                        boolean improVisorFirst,
                        int tradingQuantum)
    {
        notate = myNotate;
        currentSlot = startSlot;
        chordSlot = startSlot;
        int numSlotsToFill;
        int totalSlotsToFill = initialNumSlots;
        int padding;

        if( !whetherToTrade )
          {
            improVisorFirst = true;
            tradingQuantum = totalSlotsToFill;
          }

        //System.out.println("grammar:run " + startSlot + " initialNumSlots = " + initialNumSlots + ", tradingQuantum = " + tradingQuantum);
        // applyRules will side-effect terminalBuffer anwd numSlotsToFill
        terminalBuffer = new PolylistBuffer();

        // When trading passively, outer loop alternates melodies with rests. 
        // On each iteration both melody and rests will be potentially generated.
        // If not trading, the outer loop will be executed only once.
        while( totalSlotsToFill > 0 )
          {
            if( improVisorFirst ) // Fill now, pad later, if at all
              {
                numSlotsToFill = Math.min(tradingQuantum, totalSlotsToFill);
                totalSlotsToFill -= numSlotsToFill;
                padding = Math.min(tradingQuantum, totalSlotsToFill);
                totalSlotsToFill -= padding;
              }
            else // Pad where user would play, then fill
              {
                padding = Math.min(tradingQuantum, totalSlotsToFill);
                totalSlotsToFill -= padding;
                numSlotsToFill = Math.min(tradingQuantum, totalSlotsToFill);
                totalSlotsToFill -= numSlotsToFill;
                if( padding > 0 )
                  {
                    String fillRests = Note.getDurationString(padding);
                    terminalBuffer.append("R" + fillRests);
                  }
              }

            // Inner loop fills up to one quantum worth of abstract melody, or the
            // entire abstract melody if not trading.
            // Inner loop fills up to one quantum worth of abstract melody, or the
            // entire abstract melody if not trading.
            while( numSlotsToFill > 0 )
              {
                Polylist stack = addStart(numSlotsToFill);

                //System.out.println("\nTop Level");
                ExpansionResult result = outerFill(stack, numSlotsToFill);
                numSlotsToFill = result.numSlotsToFill;
                stack = result.stack;
                if( improVisorFirst && padding > 0 ) // Pad the user's part after
                  {
                    String fillRests = Note.getDurationString(padding);
                    terminalBuffer.append("R" + fillRests);
                  }
              }
          }
        // Return the abstract melody, truncated to the desired number of slots.
        // Truncation should not be necessary if everything was done right, but
        // it seems that we go over sometime. Not sure why.
        return Terminals.truncateAbstractMelody(terminalBuffer.toPolylist(),
                                                initialNumSlots);
    }

    private void trace(Polylist stack)
    {
        if( traceLevel > 1 )
          {
            System.out.println("STACK: " + stack + " OUT: " + terminalBuffer.
                    toPolylist());
          }
    }

    /**
     * outerFill refills the stack if numSlotsToFill > 0
     *
     * @param stack
     * @param numSlotsToFill
     * @return
     */
    ExpansionResult outerFill(Polylist stack, int numSlotsToFill)
    {
        trace(stack);

        Polylist originalStack = stack;
        while( numSlotsToFill > 0 )
          {
            if( stack.isEmpty() )
              {
                stack = originalStack;
              }

            ExpansionResult result = accumulateTerminals(stack, numSlotsToFill);
            stack = result.stack;
            numSlotsToFill = result.numSlotsToFill;

            result = applyRules(stack, numSlotsToFill);

            numSlotsToFill = result.numSlotsToFill;
            stack = result.stack;
          }
        return new ExpansionResult(stack, numSlotsToFill);
    }

    /**
     * Add terminal to the list of terminals generated, as long as the quota has
     * not been reached. Checks whether the terminal would go over quota, and
     * if so, does not add it, but set quotaReached indicator instead.
     *
     * @param terminal
     */
    private int accumulateTerminal(Object terminal, int numSlotsToFill)
    {
        //System.out.println("accumulateTerminal " + numSlotsToFill + " " + terminal);
        int duration = getDuration(terminal);
//        if( numSlotsToFill < duration )
//          {
//            //System.out.println("short slots = " + numSlotsToFill + " vs duration " + duration);
//            terminal = new Rest(numSlotsToFill);
//            duration = numSlotsToFill;
//          }
        terminalBuffer.append(terminal);
        chordSlot += duration;
        numSlotsToFill -= duration;
        return numSlotsToFill;
    }

    /**
     * Add the Start Symbol to list stack in order to start the grammar
     * expansion.
     *
     * @param numSlots
     * @return
     */
    public Polylist addStart(int numSlots)
    {
        Polylist stack = Polylist.nil;
        Polylist search = rules;

        // While the list of rules isn't empty...
        while( search.nonEmpty() )
          {
            Polylist next = (Polylist) search.first();
            search = search.rest();

            try
              {
                // See if the next rule contains the "startsymbol" tag.
                // If it does, token it on the front of the string.
                if( ((String) next.first()).equals(START) )
                  {
                    if( next.length() == 2 && next.second() instanceof String )
                      {
                        startSymbol = (String) next.second();

                        Polylist s = Polylist.list(startSymbol, numSlots);
                        stack = stack.cons(s);
                        return stack;
                      }
                    else
                      {
                        ErrorLog.log(ErrorLog.SEVERE,
                                     "Malformed start rule: " + next + ".  Abort.");
                        return null;
                      }
                  }
              }
            // Catch any syntax errors in the rule file.  At some point it might
            // be nice to actually print out what the problem is...
            catch( ClassCastException e )
              {
                ErrorLog.log(ErrorLog.SEVERE, "Malformed rules file.  Abort.");
                return null;
              }
          }

        // If it didn't find a start lhs in the file, abort.
        ErrorLog.log(ErrorLog.SEVERE, "No start symbol found.  Abort.");
        return null;
    }

    /**
     * Add a rule to the appropriate list, so that probabilities can be
     * computed and a rule then selected. Only add if the computed value of the
     * weight expression is non-negative.
     *
     * @param lhs      left-hand side of the rule
     * @param rhs      right-hand side of the rule
     * @param wtExp    weight expression of the rule (unevaluated)
     * @param ruleList list to which to add this rule
     */
    private void addToList(Polylist lhs,
                           Polylist rhs,
                           Object wtExp,
                           ArrayList<WeightedRule> ruleList)
    {
        Object wt = evaluate(wtExp);
        if( wt instanceof Number )
          {
            Double weight = ((Number) wt).doubleValue();
            if( weight > 0 )
              {
                ruleList.add(new WeightedRule(lhs, rhs, weight));
              }
          }
        else
          {
            ErrorLog.log(ErrorLog.WARNING,
                         "Invalid weight expression in grammar rule: " + wtExp);
          }
    }

    private String wrapperType(Object token)
    {
        if( token instanceof Polylist )
          {
            Polylist polylistToken = (Polylist) token;
            switch( polylistToken.length() )
              {
                case 1:
                    if( polylistToken.first().equals(UNSHAREALL) )
                      {
                        return UNSHAREALL;
                      }
                    break;

                case 2:
                    if( polylistToken.first().equals(SHARE) )
                      {
                        return SHARE;
                      }
                    if( polylistToken.first().equals(UNSHARE) )
                      {
                        return UNSHARE;
                      }
                    break;

                case 3:
                    if( polylistToken.first().equals(FILL) )
                      {
                        return FILL;
                      }
                    if( polylistToken.first().equals(MUSE_SWITCH) )
                      {
                        return MUSE_SWITCH;
                      }                    break;
              }
          }
        return NONE; // Not a wrapper
    }

    Polylist cache = Polylist.nil;

    Polylist drop(Polylist aList, Object find)
    {
        if( aList.isEmpty() )
          {
            return aList;
          }
        Polylist firstList = (Polylist) aList.first();
        if( firstList.first().equals(find) )
          {
            return aList.rest();
          }
        return drop(aList.rest(), find).cons(firstList);
    }

    public ExpansionResult expandNonTerminal(Polylist token, int slotsToFill)
    {
        //System.out.println("expandNonTerminal " + slotsToFill + " " + token);
        boolean shareable = false;
        boolean unshare = false;
        switch( wrapperType(token) )
          {
            case NONE:
                break;
                
            case FILL:
                token = ((Polylist) token).rest(); // leave as a list
                Object value = token.first();
                // Get the number of beats
                Double beats = value instanceof Double ? (Double) value : ((Long) value).
                        doubleValue();
                // Convert to slots
                int slots = (int) (beats * imp.Constants.BEAT);
                Polylist innerToken = token.rest();
                ExpansionResult result = outerFill(innerToken, slots);
                Polylist stack = result.stack.cons(Polylist.list(UNSHAREALL));
                return new ExpansionResult(stack, slotsToFill - slots);

            case MUSE_SWITCH:
                token = ((Polylist) token).rest();
                // token is now the list after muse-switch, which should be
                // two items:
                //    an argument to be evaluated (should return a Long)
                //
                //    an association list which gives a replacement 
                //    for each value that getMuseValue can return
                //    and a special default pair indicating the replacement in 
                //    case said value is not in the list
                
                Object rawMuseArgument = token.first();
                
                //System.out.println("argument to muse-switch = " + rawArgument);
                
                // Revisit: Provide a proper error message in case assertion
                // fails.
                Object evaluationResult = evaluate(rawMuseArgument);
                assert(evaluationResult instanceof Long);
                
                Long argValue = (Long)evaluationResult;
                
                Polylist alist = (Polylist)token.second();
                
                //System.out.println("muse-switch alist = " + alist);
                
                // Make sure the Muse receiver is instantiated.
                MuseReceiver receiver = ImproVisor.getMuseReceiver();
                
                // Get the value from muse, which generally depends on argValue
                // Technically we don't need the receiver. part since it's
                // static method, but doesn't hurt as a reminder.
                
                Long museValue = receiver.getMuseValue(argValue);
                
                // Find the pair having the first component equal to museValue.
                // These components should be Long (because of polya) constants,
                // or the String MUSE_DEFAULT.
                
                // If there is no match to museValue and no default specified,
                // then we continue with no replacement (??).
                // If any item in the putative association list is not a pair
                // this thing might crash. REVISIT.
                
                Polylist pair = alist.assoc(museValue);
                
                //System.out.println("pair = " + pair);
                
                // The replacement for this muse-switch expression
                Object replacement;
                
                if( pair == null )
                  {
                    replacement = alist.assoc(MUSE_DEFAULT).second();
                    if( replacement == null )
                      {
                        // Not sure if this is correct. REVISIT.
                        return applyRules(Polylist.nil, slotsToFill);
                      }
                  }
                else
                  {
                    replacement = pair.second();
                  }
                
                //System.out.println("replacement = " + replacement);
                
                return applyRules(Polylist.list(replacement), slotsToFill);

            case UNSHARE:
                unshare = true;
            // NOTE: Intentional fall-through
            case SHARE:
                shareable = true;

                token = ((Polylist) token).rest(); // leave as a list
                Object find = token.first();
                Polylist found = cache.assoc(find);
                if( found != null )
                  {
                    if( unshare )
                      {
                        cache = drop(cache, find);
                      }
                    return new ExpansionResult(found.rest(), slotsToFill);
                  }
                break;
                
            case UNSHAREALL:
                cache = Polylist.nil;
                return new ExpansionResult(Polylist.nil, slotsToFill);
          } // switch

        WeightedRule ruleToUse = findRule(token);
        if( ruleToUse == null )
          {
            return null;
          }

        Polylist expansion = ruleToUse.rhs;
        if( shareable && !unshare )
          {
            // If to be shared, put expansion in cache
            Polylist newCacheItem = ((Polylist) token).append(expansion);
            cache = cache.cons(newCacheItem);
            //System.out.println("sharing " + newCacheItem + " giving shareable " + cache);
          }

        if( traceLevel > 0 )
          {
            System.out.println("\nRULE: " + ruleToUse);
          }

        return new ExpansionResult(expansion, slotsToFill);
    }

    public WeightedRule findRule(Polylist token)
    {
        ArrayList<WeightedRule> ruleList = new ArrayList<>();
        ArrayList<WeightedRule> baseList = new ArrayList<>();

        // Find all grammar rules that apply to the given lhs.
        // Note that a start lhs can be a polylist.
        for( Polylist search = rules; search.nonEmpty(); search = search.rest() )
          {
            // Next is the next rule to compare to
            Polylist next = (Polylist) search.first();
            if( next == null | next.isEmpty() | !(next.first() instanceof String) )
              {
                continue;
              }
            String type = (String) next.first();
            //System.out.println("\nnext = " + next);

            //System.out.println("matching LHS " + goal);
            /*
             * RULEs and BASEs have the following S-expression format:
             * (<keyword> (<LHS lhs>) (<RHS>) weight)
             * <keyword> can be "rule" or "base"
             * <LHS lhs> can be a string or a polylist of strings
             * <RHS> is a polylist of symbols (or if it's a RULE, some
             * expressions
             * to evaluate).
             * <weight> is a double expressing how "important" the rhs is. More
             * important
             * rules will be chosen more often than less important ones.
             */
            // The BASE keyword stops all evalution and variable substitution.
            // If a lhs matches both a RULE and a BASE, it will always choose the BASE.
            // This basically short-circuits any computation and provides an easy way
            // to find base cases.
            if( type.equals(BASE) && next.length() == 4 )
              {
                //System.out.println("\nbase = " + next);
                Polylist lhs = (Polylist) next.second();
                Polylist rhs = (Polylist) next.third();

                if( token.equals(lhs) )
                  {
                    //addToList(lhs, rhs, next.fourth(), baseList);
                  }
              }
            // Most objects will have type RULE.
            else if( type.equals(RULE) && next.length() == 4 )
              {
                //System.out.println("\nrule = " + next);
                Object rawLHS = next.second();
                Object rawRHS = next.third();
                Polylist lhs;
                Polylist rhs;
                if( rawLHS instanceof Polylist )
                   {
                    lhs = (Polylist)rawLHS;
                   }
                else
                   {
                     lhs = Polylist.list(rawLHS);
                   }
                if( rawRHS instanceof Polylist )
                   {
                    rhs = (Polylist)rawRHS;
                   }
                else
                   {
                     rhs = Polylist.list(rawRHS);
                   }
                
                //System.out.println(" rhs before evaluation  " + rhs);
                //System.out.println("token = " + token);
                if( token instanceof Polylist
                        && ((Polylist) token).first() instanceof String )
                  {
                    if( ((String) ((Polylist) token).first()).
                            equals(lhs.first()) )
                      {
                        // Unify variables with their given numeric values,
                        // in preparation for evaluation.
                        rhs = setVars((Polylist) token, lhs, rhs);

                        // A null result means that unification failed.
                        if( rhs == null )
                          {
                            continue;
                          }

                        //System.out.println(" rhs after setVars " + rhs);
                        // Evaluate any expressions that need to be evaluated.
                        rhs = (Polylist) evaluate(rhs);

                        //System.out.println(" rhs after evaluation of " + token + ": " + rhs);
                        // Check for negative arguments in RHS,
                        // In which case don't use RHS
                        boolean valid = true;
                        PolylistEnum L = rhs.elements();
                        polya.PolylistBuffer B = new polya.PolylistBuffer();
                        while( L.hasMoreElements() )
                          {
                            Object ob = L.nextElement();
                            if( ob instanceof Polylist )
                              {
                                Polylist P = (Polylist) ob;

                                if( P.length() == 2 && P.first().equals(
                                        startSymbol) )
                                  {
                                    // We found the start lhs on the RHS.
                                    // Only pass it if argument is non-negative.
                                    // FIX: Replace this with a more sound mechanism.

                                    Object arg = P.second();
                                    if( arg instanceof Number && ((Number) arg).
                                            intValue() <= 0 )
                                      {
                                        //valid = false;
                                        //System.out.println("abandoning: " + rhs);
                                        //break;
                                      }
                                    else
                                      {
                                        B.append(ob);
                                      }
                                  }
                                else
                                  {
                                    B.append(ob);
                                  }
                              }
                            else
                              {
                                B.append(ob);
                              }
                          } // while

                        rhs = B.toPolylist();

                        if( valid )
                          {
                            addToList(lhs, rhs, next.fourth(), ruleList);
                          }
                      }
                  }
              }
          }

        // Give baseList priority over ruleList.
        ArrayList<WeightedRule> listToUse = baseList.isEmpty() ? ruleList : baseList;

        //System.out.println("listToUse = " + listToUse);
        if( listToUse.isEmpty() )
          {
            if( traceLevel > 0 )
              {
                System.out.println("*** No rule found for token: " + token);
              }
          }
        else
          {
            // Sum up all the weights for normalization.	    
            double total = 0.0;
            for( WeightedRule weightedRule : listToUse )
              {
                total += weightedRule.getWeight();
              }

            // Generate a random number to find out which rule to use.
            double rand = total * Math.random();
            double offset = 0.0;

            int listSize = listToUse.size();

            WeightedRule ruleToUse = null;
            // Loop through all rules up to one in the probability interval,
            // the break.
            for( WeightedRule weightedRule : listToUse )
              {
                // If the random number falls between the range of the probability 
                // for that rule, we choose it and break out of the loop.
                double rule_weight = weightedRule.getWeight();
                if( rand >= offset && rand < (offset + rule_weight) )
                  {
                    //System.out.println("rule found");
                    ruleToUse = weightedRule;
                    break;
                  }
                offset += rule_weight;
              }

            if( ruleToUse == null && listSize > 0 )
              {
                // Use the last rule in the list.
                ruleToUse = listToUse.get(listSize - 1);
              }
            return ruleToUse;
          }
        return null;
    }

    private ExpansionResult accumulateTerminals(Polylist stack,
                                                int numSlotsToFill)
    {
        Object token;

        // Accumulate any terminal values at the beginning of stack.
        while( numSlotsToFill > 0 && stack.nonEmpty() )
          {
            token = stack.first();
            if( !isTerminal(token) )
              {
                return new ExpansionResult(stack, numSlotsToFill);
              }

            if( isWrappedTerminal(token) )
              {
                numSlotsToFill = accumulateTerminal(((Polylist) token).first(),
                                                    numSlotsToFill);
              }
            else
              {
                numSlotsToFill = accumulateTerminal(token, numSlotsToFill);
              }

            stack = stack.rest();
          }
        return new ExpansionResult(stack, numSlotsToFill);
    }

    /**
     * Pop tokens off the stack stack. Any terminal tokens are pushed onto
     * accumulator. Rules are applied to non-terminals.
     *
     * @param stack
     * @return
     * @throws imp.lickgen.RuleApplicationException
     */
    public ExpansionResult applyRules(Polylist stack, int numSlotsToFill)
    {
        if( stack.isEmpty() )
          {
            return new ExpansionResult(stack, numSlotsToFill);
          }
        //System.out.println("applyRules " + numSlotsToFill + " " + stack);
        Object token = stack.first();
        stack = stack.rest();

        // token is a non-terminal
        if( !(token instanceof Polylist) )
          {
            token = Polylist.list(token);
          }

        ExpansionResult result = expandNonTerminal((Polylist) token,
                                                   numSlotsToFill);
        if( result == null ) // How can this happen?
          {
            return new ExpansionResult(stack, numSlotsToFill);
          }
        //System.out.println("after expandNonTerminal " + result);
        numSlotsToFill = result.numSlotsToFill;
        Polylist expansion = result.stack;

        stack = expansion.append(stack);

        trace(stack);

        return new ExpansionResult(stack, numSlotsToFill);
    }

    public Polylist addRule(Polylist toAdd)
    {
        rules = rules.cons(toAdd);
        return rules;
    }

    /**
     * Set the value of param in the list of all rules,
     * preserving a unique value for each parameter.
     *
     * @param param
     * @param value
     */
    public void setParameter(String param, Object value)
    {
        PolylistBuffer buffer = new PolylistBuffer();
        boolean found = false;
        while( rules.nonEmpty() )
          {
            Polylist first = (Polylist) rules.first();
            if( first.first().equals(PARAM) )
              {
                Polylist second = (Polylist) first.second();
                if( second.first().equals(param) )
                  {
                    found = true;
                    buffer.append(Polylist.list(PARAM, Polylist.list(param,
                                                                     value)));
                  }
                else
                  {
                    buffer.append(first);
                  }
              }
            else
              {
                // If first is not a parameter, pass it on unchanged.
                buffer.append(first);
              }
            rules = rules.rest();
          }
        if( !found )
          {
            buffer.append(Polylist.list(PARAM, Polylist.list(param, value)));
          }
        rules = buffer.toPolylist();
    }

    public Polylist getRules()
    {
        return rules;
    }

// Load the rules in from a file.
    public int loadGrammar(String filename)
    {
        //System.out.println("Grammar loadGrammar " + filename);
        PolylistBuffer buffer = new PolylistBuffer();
        try
          {
            Tokenizer in = new Tokenizer(new FileInputStream(filename));
            Object ob;

            while( (ob = in.nextSexp()) != Tokenizer.eof )
              {
                //System.out.println("ob = " + ob);
                if( ob instanceof Polylist )
                  {
                    buffer.append(ob);
                  }
              }
            rules = buffer.toPolylist();
            return 0;
          }
        catch( FileNotFoundException e )
          {
            ErrorLog.log(ErrorLog.SEVERE,
                         "File " + filename + " not found.  Abort.");
            return -1;
          }
    }

    public int saveGrammar(String filename)
    {
        //  System.out.println("rules = " + rules);
        try
          {
            Polylist toWrite = rules;
            StringBuilder buffer = new StringBuilder();
            while( toWrite.nonEmpty() )
              {
                buffer.append(toWrite.first());
                buffer.append("\n");
                toWrite = toWrite.rest();
              }
            FileWriter out = new FileWriter(new File(filename));
            out.write(buffer.toString());
            out.close();
            //System.out.println("\n\nsaveGrammar\n" + buffer.toString());
            return 0;
          }
        catch( IOException e )
          {
            ErrorLog.log(ErrorLog.WARNING, "Error saving to " + filename);
            return -1;
          }
    }

    /**
     * Set all instances of variables in toSet corresponding value in
     * getValsFrom.
     * This is a unilateral unification.
     */
    private Polylist setVars(Polylist getValsFrom,
                             Polylist getVarsFrom,
                             Polylist toSet)
    {
        // skip first element, which is a functor
        Polylist vars = getVarsFrom.rest();
        Polylist vals = getValsFrom.rest();
        while( vars.nonEmpty() && vals.nonEmpty() )
          {
            Object var = vars.first();
            Object val = vals.first();
            if( (var instanceof Number) && (val instanceof Number) )
              {
                if( ((Number) var).longValue() != ((Number) val).longValue() )
                  {
                    return null;  // not unifiable
                  }
              }
            else if( (var instanceof String) && (val instanceof Number) )
              {
                toSet = replace(var.toString(), ((Number) val).longValue(),
                                toSet);
              }
            else if( (var instanceof String) && (val instanceof String) )
              {
                if( !var.equals(val) )
                  {
                    return null;  // not unifiable  
                  }
              }
            else
              {
                return null; // not unifiable
              }

            vars = vars.rest();
            vals = vals.rest();
          }
        return toSet;
    }

// Evaluate will perform arithmetic evaluation on its S-Expression argument.
// (+ 3 4) evaluates to 7
// (+ (/ 4 2) (* 7 3)) evaluates to 23
//
// As of 21 June 2012, evaluate can accept builtins, of the form
// (builtin <some identifier>)
// Right now, the only identifier is "expectancy". Evaluation of this identifier
// is stubbed to return 1. Any other identifier will return 0.
// Eventually, the value of the builtin identifier may change depending on the
// then-current slot.
    private Object evaluate(Object toParse)
    {
        //System.out.println("currentSlot = " + currentSlot);
        // Base case:
        if( toParse instanceof Number || toParse instanceof String )
          {
            return toParse;
          }
        else if( toParse instanceof Polylist && ((Polylist) toParse).nonEmpty() )
          {
            try
              {
                // Recursively evaluate until we get down to two numbers we can add.
                Polylist parsing = (Polylist) toParse;

                if( BUILTIN.equals(parsing.first()) )
                  {
                    Object value = evaluateBuiltin(parsing.second(), parsing.third());
                    //System.out.println("evaluate value = " + value);
                    return value;
                  }
                else if( PLUS.equals(parsing.first()) )
                  {
                    return Arith.add(evaluate(parsing.second()), evaluate(
                                     parsing.third()));
                  }
                else if( MINUS.equals(parsing.first()) )
                  {
                    return Arith.subtract(evaluate(parsing.second()), evaluate(
                                          parsing.third()));
                  }
                else if( TIMES.equals(parsing.first()) )
                  {
                    return Arith.multiply(evaluate(parsing.second()), evaluate(
                                          parsing.third()));
                  }
                else if( DIVIDE.equals(parsing.first()) )
                  {
                    return Arith.divide(evaluate(parsing.second()), evaluate(
                                        parsing.third()));
                  }
                else
                  {
                    Polylist p = Polylist.nil;
                    Polylist L = parsing;
                    while( L.nonEmpty() )
                      {
                        p = Polylist.cons(evaluate(L.first()), p);
                        L = L.rest();
                      }
                    p = p.reverse();
                    return p;
                  }
              }
            catch( ClassCastException e )
              {
                ErrorLog.log(ErrorLog.SEVERE,
                             "Bad cast operation in evaluation of " + toParse);
                return null;
              }
          }
        else
          {
            return null;
          }
    }

    /**
     * Evaluate the rest of a special form (splice <operator> <arg> ...)
     * (<operator>
     * <arg> ...) must return a list. Currently the only operator available is
     * literal, e.g. a rule RHS of the form (C4 (splice literal C8 C8) (splice
     * literal C16 C16 C16 C16) R4) returns (C4 C8 C8 C16 C16 C16 C16 R4)
     *
     * It is expected that additional splice-oriented operators will be added,
     * and
     * not all will just use literal arguments.
     *
     * @param form
     * @return
     */
    Polylist evaluateSplice(Polylist form)
    {
        if( form.isEmpty() )
          {
            return Polylist.nil;
          }

        Object operator = form.first();
        Polylist args = form.rest();

        if( LITERAL.equals(operator) )
          {
            return args;
          }

        return Polylist.nil;
    }

    public int getCurrentSlot()
    {
        return currentSlot;
    }

    /**
     * Evaluates the arguments following the builtin operator. So far only
     * implemented for expectancy and syncopation
     *
     * @param arg1
     * @param arg2
     * @return
     */
    private Object evaluateBuiltin(Object arg1, Object arg2)
    {
        //System.out.println("\nevaluate-builtin " + arg1 + " " + arg2);
        ChordPart chords = notate.getChordProg();
        if( arg1 instanceof String && ((String) arg1).equals(CHORD_FAMILY) )
          {
            if( !(arg2 instanceof Polylist) )
              {
                return 0;
              }

            Polylist families = (Polylist) arg2;

            Chord currentChord = chords.getCurrentChord(chordSlot);

            if( currentChord == null )
              {
                return ZERO;
              }
            String family = currentChord.getFamily();
            //System.out.println("family " + family + " " + currentChord + " families " + families);
            return families.member(family) ? ONE : ZERO;
          }
        // Is evaluable of the form (builtin brick <brickname>)
        if( BRICK.equals(arg1) )
          {
            //System.out.println("evaluating brick at slot " + chordSlot);
            if( !(arg2 instanceof String) )
              {
                return ZERO;
              }

            String brickname = (String) arg2;

            notate.ensureRoadmap();
            Block currentBlock = chords.getBlockAtSlot(chordSlot);

            if( currentBlock == null )
              {
                return ZERO;
              }

            String blockName = currentBlock.getDashedName();

            if( brickname.equals(blockName) )
              {
                if( traceLevel > 0 )
                  {
                    System.out.println("At slot " + chordSlot
                            + " considering brick " + brickname);
                  }
                return ONE;
              }

            //System.out.println("At slot " + chordSlot 
            //           + " brickname " + brickname + " doesn't match " + blockName);
            return 0.1; //ZERO;
          }
        
        return ZERO;
    }
    
    /**
     * Recursively replace all instances of varName with value in toReplace
     */
    private Polylist replace(String varName, Long value, Polylist toReplace)
    {
        Polylist toReturn = Polylist.nil;

        Polylist L = toReplace;

        while( L.nonEmpty() )
          {
            if( L.first() instanceof Polylist )
              {
                toReturn = toReturn.cons(replace(varName, value, (Polylist) L.
                                                 first()));
              }
            else if( varName.equals(L.first()) )
              {
                toReturn = toReturn.cons(value);
              }
            else
              {
                toReturn = toReturn.cons(L.first());
              }
            L = L.rest();
          }
        //System.out.println("replace var " + varName + " with " + value + " in " + toReplace + " giving " + toReturn.reverse());
        return toReturn.reverse();
    }

    /**
     * Inner class representation of rules with weights, for probabilistic
     * evaluation.
     */
    class WeightedRule
      {
        Polylist lhs;
        Polylist rhs;
        double weight;

        WeightedRule(Polylist lhs, Polylist rhs, double weight)
        {
            this.lhs = lhs;
            this.rhs = rhs;
            this.weight = weight;
        }

        Polylist getRHS()
        {
            return rhs;
        }

        double getWeight()
        {
            return weight;
        }

        ExpansionResult addToGen(Polylist gen, int numSlotsToFill)
        {
            boolean onlyTerminalsSoFar = true;
            PolylistBuffer afterFirstTerminals = new PolylistBuffer();

            for( Polylist L = rhs; L.nonEmpty(); L = L.rest() )
              {
                Object next = L.first();
                if( onlyTerminalsSoFar && isTerminal(next) )
                  {
                    numSlotsToFill = accumulateTerminal(next, numSlotsToFill);
                  }
                else
                  {
                    onlyTerminalsSoFar = false;
                    if( next instanceof Polylist )
                      {
                        afterFirstTerminals.append(next);
                      }
                    else
                      {
                        afterFirstTerminals.append(Polylist.list(next));
                      }
                  }
              }
            return new ExpansionResult(
                    afterFirstTerminals.toPolylist().append(gen), numSlotsToFill);
        }

        @Override
        public String toString()
        {
            return lhs + " -> " + rhs + " [prob " + weight + "]";
        }
      }
  }
